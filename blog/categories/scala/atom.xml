<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | Ice Write Blog]]></title>
  <link href="http://iceongrass.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://iceongrass.github.io/"/>
  <updated>2013-11-24T00:11:22+08:00</updated>
  <id>http://iceongrass.github.io/</id>
  <author>
    <name><![CDATA[iceongrass]]></name>
    <email><![CDATA[iceongrass@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scala 学习笔记（1）]]></title>
    <link href="http://iceongrass.github.io/blog/2013/11/23/scalastudynote1/"/>
    <updated>2013-11-23T22:54:00+08:00</updated>
    <id>http://iceongrass.github.io/blog/2013/11/23/scalastudynote1</id>
    <content type="html"><![CDATA[<p>接触Scala已经有一段时间时间了，但是没有从基础开始学起总是觉得缺些什么。于是入手了《快学Scala》准备系统学习，顺便一边学一边记记笔记吧。</p>

<!--more-->


<hr />

<h2>语法上的差异</h2>

<p>简单的语法方面的内容，之前的<a href="http://iceongrass.com/blog/2013/11/11/scalahen-shen-qi/">《Scala很神奇》</a>中简单的提到了一些，总结一下的话大概有这么几点：</p>

<ul>
<li>除了val（常量）和var（变量）以外，在scala shell中的任何代码段和表达式都会被分配给一个名称，可以通过这些明称直接访问名称内的值，比如说</li>
</ul>


<p><code>scala
scala&gt; val tmp = 8 * 2 + 3
res0: Int = 19
scala&gt; res0 + 8
res1: Int = 27
</code></p>

<ul>
<li>如上例所示，变量和函数在声明的时候并不需要人为指定变量类型（递归函数除外）。但若要指定类型可以这样：</li>
</ul>


<p><code>scala
def sum(a:Int, b:Int) : Int = a + b
</code></p>

<ul>
<li><p>数据类型方面，区别于java，scala中没有基本类型，所有的类型（包括Int，Float，Boolean等）都是类。</p></li>
<li><p>关于操作符，个人感觉scala中的设计到运算操作符似乎全都被重载过。最典型的一个表达式<code>a + b</code>实际上可以理解为<code>a.+(b)</code>。实际上操作符<code>+</code>本身已经不是个运算符了，而是一个Int对象a的方法。这在Java中是不被允许的。（所以从这个角度来讲，scala要比java更加面向对象的）</p></li>
<li><p>引用外部库的时候，java库是可以直接import使用的，过程中的区别大概只是如果你想<code>import java.lang.math.*</code>，那么现在你需要<code>import java.lang.math._</code></p></li>
</ul>


<p>这当然不全了，我才读到第三章而已，以后发现了再补充哈。</p>

<hr />

<h2>代码结构和函数</h2>

<p>相对于Java、C++中语句（执行动作）和表达式（数值计算）作用的不同，scala中所有的语法结构似乎都是为了求值而存在的。这里我也总结了几点差异：</p>

<ol>
<li>if表达式是带值的。</li>
<li>代码块也带值，一般式最后一个表达式的计算结果。</li>
<li><code>;</code>这个东西在scala中是不必要的。你当然可以像是在java中那样使用<code>;</code>，但如果你不是想把多个表达式放在同一行的话，那基本上是没必要用的。</li>
<li>void类型在scala中是Unit。</li>
<li>return这个东西尽量不要出现，默认语法块的最后一个表达式回返回计算值。</li>
<li>没有编译检查。</li>
<li><code>i &lt;- expr</code>表示用i去遍历右边的表达式，该表达式的值一般为一个容器（collection）。</li>
<li>函数按功能可以分为两类，计算用的函数是要计算和返回值的；另一种函数只是去做了一件事情（可以称作副作用），而它的返回值没有意义，这样的函数一般返回Unit类型。函数定义的时候，前者的定义和代码需要通过<code>=</code>连接，后者则省略了<code>=</code>。</li>
<li>Scala中有一个‘懒值‘的概念，表现为变量声明时：</li>
</ol>


<p><code>scala
lazy val word = io.Source.fromFile("/A/Reachable/Path/File.txt").mkString
</code></p>

<p>这段代码在不被求值的时候是不会被初始化的，所以在代码在执行的过程中，如果word的值从来没有被用到，那么即使后面填的文件路径是错的也不会有异常被抛出来。</p>
]]></content>
  </entry>
  
</feed>
